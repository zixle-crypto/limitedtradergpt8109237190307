You‚Äôre right to question it ‚Äî Builderman Egg is Limited + tradable, so ‚Äúno resale market‚Äù isn‚Äôt the full story.

What‚Äôs actually happening is this:

Why you can get 404 even for a Limited

Roblox now has two different resale-data systems, depending on the item:

Path A) AssetId-based resale endpoints (older/classic)

https://economy.roblox.com/v1/assets/{assetId}/resale-data

https://economy.roblox.com/v1/assets/{assetId}/resale-history

Path B) CollectibleItemId-based resale endpoints (newer/UGC/collectible system)

Roblox requires a collectibleItemId for resale + charts:

https://apis.roblox.com/marketplace-sales/v1/item/{collectibleItemId}/resale-data

So your bridge is probably calling Path A, and Roblox is saying ‚Äúnope, not found‚Äù for that item under that route ‚Äî even though it‚Äôs limited.

‚úÖ The real fix: support BOTH systems (automatic fallback)
Step 1) Get the item‚Äôs collectibleItemId

Your catalog/items/details response often includes something like collectibleItemId (or a nested collectible field). DevForum confirms you need that for resale data in some cases.

Step 2) If collectibleItemId exists ‚Üí use marketplace-sales endpoints

Else ‚Üí use economy endpoints

üîß Paste this patch into your Python bridge
1) Add these URLs (near your config)
ROBLOX_MARKETPLACE_SALES_RESALE_DATA = "https://apis.roblox.com/marketplace-sales/v1/item/{collectible_item_id}/resale-data"
ROBLOX_MARKETPLACE_SALES_RESALE_HISTORY = "https://apis.roblox.com/marketplace-sales/v1/item/{collectible_item_id}/resale-history"

2) Add this helper to safely read collectibleItemId
def _extract_collectible_item_id(roblox_details: Dict[str, Any]) -> Optional[str]:
    # Common field names seen in the wild:
    # - collectibleItemId
    # - collectibleItemId in nested "collectible" object
    for k in ("collectibleItemId", "collectible_item_id"):
        v = roblox_details.get(k)
        if v:
            return str(v)

    collectible = roblox_details.get("collectible")
    if isinstance(collectible, dict):
        v = collectible.get("collectibleItemId") or collectible.get("id")
        if v:
            return str(v)

    return None

3) Replace your resale fetchers with ‚Äúdual path‚Äù
def get_resale_data_dual(asset_id: int, collectible_item_id: Optional[str]) -> Dict[str, Any]:
    # Prefer collectible system if available
    if collectible_item_id:
        return _http_get_json(ROBLOX_MARKETPLACE_SALES_RESALE_DATA.format(collectible_item_id=collectible_item_id))
    return _http_get_json(ROBLOX_RESALE_DATA_URL.format(asset_id=asset_id))


def get_resale_history_dual(asset_id: int, collectible_item_id: Optional[str]) -> Dict[str, Any]:
    if collectible_item_id:
        return _http_get_json(ROBLOX_MARKETPLACE_SALES_RESALE_HISTORY.format(collectible_item_id=collectible_item_id))
    return _http_get_json(ROBLOX_RESALE_HISTORY_URL.format(asset_id=asset_id))

4) Update /market/item/analyze to use the dual fetch

Inside your analyzer, after you get roblox = get_catalog_details(asset_id) do:

collectible_item_id = _extract_collectible_item_id(roblox)

resale_data = None
resale_history = None
market_notes = []

try:
    resale_data = get_resale_data_dual(asset_id, collectible_item_id)
except HTTPException as e:
    market_notes.append(f"Resale-data unavailable (status {e.status_code}).")

try:
    resale_history = get_resale_history_dual(asset_id, collectible_item_id)
except HTTPException as e:
    market_notes.append(f"Resale-history unavailable (status {e.status_code}).")

market = {
    "fmv": None,
    "rap_like": None,
    "demand": "Unknown",
    "trend": "Unknown",
    "projected": False,
}

if resale_history and isinstance(resale_history, dict) and resale_history.get("data"):
    market = compute_market_stats(resale_data or {}, resale_history)

return {
    "source": "roblox-only:full-analysis",
    "catalog_url": catalog_url,
    "asset_id": asset_id,
    "roblox": roblox,
    "collectible_item_id": collectible_item_id,
    "resale_data": resale_data,
    "resale_history": resale_history,
    "market": market,
    "analysis": {
        "notes": [
            "Roblox catalog details fetched successfully.",
            *market_notes,
        ],
    },
}


‚úÖ This will fix items like Builderman Egg where one system 404s but the other works.

About that ‚ÄúXSRF token invalid‚Äù you saw

On Roblox, that usually means your POST needs a CSRF token (not Rolimon‚Äôs). Your earlier CSRF retry patch is still correct ‚Äî just make sure it‚Äôs deployed.